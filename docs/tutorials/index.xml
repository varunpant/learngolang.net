<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tutorials on Go tutorials and examples.</title><link>https://learngolang.net/tutorials/</link><description>Recent content in Tutorials on Go tutorials and examples.</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 May 2019 23:17:54 +0100</lastBuildDate><atom:link href="https://learngolang.net/tutorials/index.xml" rel="self" type="application/rss+xml"/><item><title>Print Look and Say Sequence in Go</title><link>https://learngolang.net/tutorials/print-look-and-say-sequence-in-go/</link><pubDate>Sun, 05 May 2019 23:17:54 +0100</pubDate><guid>https://learngolang.net/tutorials/print-look-and-say-sequence-in-go/</guid><description>Look-and-say sequence In mathematics, the look-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, ...
To generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:
1 is read off as &amp;ldquo;one 1&amp;rdquo; or 11. 11 is read off as &amp;ldquo;two 1s&amp;rdquo; or 21.</description></item><item><title>How to convert integer to english words in go</title><link>https://learngolang.net/tutorials/how-to-convert-integer-to-english-words-in-golang/</link><pubDate>Fri, 26 Apr 2019 11:21:19 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-convert-integer-to-english-words-in-golang/</guid><description>The following code converts number to their english spelling.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func main() { for i := 0; i &amp;lt;= 10000; i++ { fmt.Println(i, spell(i)) } // i := 88 // fmt.Println(i, spell(i)) } func pow(i int, p int) int { return int(math.Pow(1000, float64(p))) } func spell(n int) string { to19 := []string{&amp;#34;One&amp;#34;, &amp;#34;Two&amp;#34;, &amp;#34;Three&amp;#34;, &amp;#34;Four&amp;#34;, &amp;#34;Five&amp;#34;, &amp;#34;Six&amp;#34;, &amp;#34;Seven&amp;#34;, &amp;#34;Eight&amp;#34;, &amp;#34;Nine&amp;#34;, &amp;#34;Ten&amp;#34;, &amp;#34;Eleven&amp;#34;, &amp;#34;Twelve&amp;#34;, &amp;#34;,Thirteen&amp;#34;, &amp;#34;Fourteen&amp;#34;, &amp;#34;Fifteen&amp;#34;, &amp;#34;Sixteen&amp;#34;, &amp;#34;Seventeen&amp;#34;, &amp;#34;Eighteen&amp;#34;, &amp;#34;Nineteen&amp;#34;} tens := []string{&amp;#34;Twenty&amp;#34;, &amp;#34;Thirty&amp;#34;, &amp;#34;Forty&amp;#34;, &amp;#34;Fifty&amp;#34;, &amp;#34;Sixty&amp;#34;, &amp;#34;Seventy&amp;#34;, &amp;#34;Eighty&amp;#34;, &amp;#34;Ninety&amp;#34;} if n == 0 { return &amp;#34;&amp;#34; } if n &amp;lt; 20 { return to19[n-1] } if n &amp;lt; 100 { return tens[n/10-2] + &amp;#34; &amp;#34; + spell(n%10) } if n &amp;lt; 1000 { return to19[n/100-1] + &amp;#34; Hundred &amp;#34; + spell(n%100) } for idx, w := range []string{&amp;#34;Thousand&amp;#34;, &amp;#34;Million&amp;#34;, &amp;#34;Billion&amp;#34;} { p := idx + 1 if n &amp;lt; pow(1000, (p+1)) { return spell(n/pow(1000, p)) + &amp;#34; &amp;#34; + w + &amp;#34; &amp;#34; + spell(n%pow(1000, p)) } } return &amp;#34;error&amp;#34; }</description></item><item><title>How to solve ransom note problem in go</title><link>https://learngolang.net/tutorials/ransom-note-problem/</link><pubDate>Sun, 21 Apr 2019 11:21:19 +0100</pubDate><guid>https://learngolang.net/tutorials/ransom-note-problem/</guid><description>Here is a solution using an array for solving ransom note problem in golang.
package main import &amp;#34;fmt&amp;#34; func main() { note := buildCharFrequencyTable(&amp;#34;ma said&amp;#34;) magzine := buildCharFrequencyTable(&amp;#34;aaimmds&amp;#34;) fmt.Println(canBuildNote(note, magzine)) } func buildCharFrequencyTable(str string) []int { counter := []int{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, } for _, char := range str { c := int(char - &amp;#39;a&amp;#39;) if c &amp;gt; 0 { counter[c]++ } } return counter } func canBuildNote(note []int, magzine []int) bool { for i := 0; i &amp;lt; len(magzine); i++ { if note[i] &amp;gt; magzine[i] { return false } } return true } Here is another solution to this problem using a hashtable</description></item><item><title>How to convert number to roman numerals</title><link>https://learngolang.net/tutorials/how-to-convert-numbers-to-roman-numerals-in-golang/</link><pubDate>Mon, 15 Apr 2019 11:21:19 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-convert-numbers-to-roman-numerals-in-golang/</guid><description>Summary Converting integers to markdown is fairly simple.
Here are 13 roman numerals and their decimal equivalent.
Decimal Roman 1 I 4 IV 5 V 9 IX 10 X 40 XL 50 L 90 XC 100 C 400 CD 500 D 900 CM 1000 M The process is as follows, for any given decimal number X:</description></item><item><title>Count number of binary search tree created for array of size n</title><link>https://learngolang.net/tutorials/count-number-of-binary-search-tree-created-for-array-of-size-n/</link><pubDate>Fri, 09 Nov 2018 21:47:32 +0000</pubDate><guid>https://learngolang.net/tutorials/count-number-of-binary-search-tree-created-for-array-of-size-n/</guid><description>This problem is an example of &amp;ldquo;catalan Numbers problem&amp;rdquo;
The Question is as follows Count number of binary search tree created for array of size n
Solution in golang package main import ( &amp;#34;fmt&amp;#34; ) func main() { for i := 0; i &amp;lt; 20; i++ { fmt.Println(i, countTreesRec(i)) } } func countTreesRec(numKeys int) int { if numKeys &amp;lt;= 1 { return 1 } else { sum := 0 for root := 1; root &amp;lt;= numKeys; root++ { left := countTreesRec(root - 1) right := countTreesRec(numKeys - root) sum += left * right } return sum } }</description></item><item><title>Find Nth Catalan Number in Golang</title><link>https://learngolang.net/tutorials/find-nth-catalan-number-in-golang/</link><pubDate>Fri, 09 Nov 2018 20:52:48 +0000</pubDate><guid>https://learngolang.net/tutorials/find-nth-catalan-number-in-golang/</guid><description>Compute n'th Catalan number In combinatorial mathematics, the Catalan numbers form a sequence of natural numbers that occur in various counting problems, often involving recursively-defined objects. They are named after the Belgian mathematician Eug√®ne Charles Catalan.
They can be computed using this formula:
C(2n, n)/(n + 1)
Read more about them here
Recursive code in go func main() { for i := 0; i &amp;lt; 20; i++ { fmt.Println(i, catalan(i)) } //0 1 //1 1 //2 2 //3 5 //4 14 //5 42 //6 132 //7 429 //8 1430 //9 4862 //10 16796 //11 58786 //12 208012 //13 742900 //14 2674440 //15 9694845 //16 35357670 //17 129644790 //18 477638700 //19 1767263190 } // catalan(n) is sum of catalan(i)*catalan(n-i-1) func catalan(n int) int { // Base case if n &amp;lt;= 1 { return 1 } res := 0 for i := 0; i &amp;lt; n; i++ { res += catalan(i) * catalan(n-i-1) } return res } Using Binomial Coefficient We can also use the below formula to find nth catalan number in O(n) time.</description></item><item><title>How to Remove Duplicates From Sorted Array in Go</title><link>https://learngolang.net/tutorials/how-to-remove-duplicates-from-sorted-array-in-go/</link><pubDate>Fri, 09 Nov 2018 20:02:06 +0000</pubDate><guid>https://learngolang.net/tutorials/how-to-remove-duplicates-from-sorted-array-in-go/</guid><description>Problem Statement Given a sorted array of numbers, remove the duplicates in-place such that each element appear only once and return the new length.
Example 1 Given nums = [1,1,2],
Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
It doesn't matter what you leave beyond the returned length.
Example 2 Given nums = [0,0,1,1,1,2,2,3,3,4],</description></item><item><title>How to Remove All Files in a Directory in Go</title><link>https://learngolang.net/tutorials/how-to-remove-all-files-in-a-directory-in-go/</link><pubDate>Sun, 04 Nov 2018 12:45:25 +0000</pubDate><guid>https://learngolang.net/tutorials/how-to-remove-all-files-in-a-directory-in-go/</guid><description>Built in Options There, always is a need to delete all files in a directory in golang.
os.RemoveAll function is used a lot. The documentation says,
RemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error).
Here is a quick example func main() { err := os.RemoveAll(&amp;#34;files&amp;#34;) fmt.</description></item><item><title>How to copy a file in go</title><link>https://learngolang.net/tutorials/how-to-copy-file-in-go/</link><pubDate>Fri, 12 Oct 2018 21:21:19 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-copy-file-in-go/</guid><description>Here is a snippet, which copies a file from source to destination.
package main import ( &amp;#34;io&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) func main() { // Open original file source, err := os.Open(&amp;#34;foo.txt&amp;#34;) if err != nil { log.Fatal(err) } defer source.Close() // Create new file destination, err := os.Create(&amp;#34;bar.txt&amp;#34;) if err != nil { log.Fatal(err) } defer destination.Close() // Copy the bytes to destination from source bytesWritten, err := io.</description></item><item><title>How to truncate a file in go</title><link>https://learngolang.net/tutorials/how-to-truncate-a-file-in-go/</link><pubDate>Fri, 05 Oct 2018 22:33:21 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-truncate-a-file-in-go/</guid><description>Truncating a file is very rare but incase yer wondering how to do it in go, here is a snippet.
This code will truncate a file to 50 bytes. If the file is less than 50 bytes the original contents will remain at the beginning, and the rest of the space is filled will null bytes.
If it is over 50 bytes, then everything after 50 bytes will be lost.</description></item><item><title>How to append in a file in go</title><link>https://learngolang.net/tutorials/how-to-append-in-a-file-in-go/</link><pubDate>Fri, 05 Oct 2018 22:20:24 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-append-in-a-file-in-go/</guid><description>Here is a snippet which shows how to append data in a file in golang.
We will use os.OpenFile with os._APPEND flag.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { for i := 0; i &amp;lt; 10; i++ { append(fmt.Sprintf(&amp;#34;line %d \n&amp;#34;, i)) } } func append(text string) { f, err := os.OpenFile(&amp;#34;myfile.txt&amp;#34;, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) if err != nil { panic(err) } defer f.Close() f.WriteString(text) } Here is a handly list of other flags which can be combined togther and used</description></item><item><title>How to change permission, timestamps and ownership of a file in go</title><link>https://learngolang.net/tutorials/how-to-change-permission-timestamps-and-ownership-of-a-file-in-go/</link><pubDate>Fri, 05 Oct 2018 21:21:19 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-change-permission-timestamps-and-ownership-of-a-file-in-go/</guid><description>Change Permission Package os, has a handy Chmod method, just like the command line interface in Linux .
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { err := os.Chmod(&amp;#34;myfile.txt&amp;#34;, 0777) if err != nil { fmt.Println(err) } } Change Ownership There is also a Chown
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { err := os.Chown(&amp;#34;myFile.txt&amp;#34;, os.Getuid(), os.Getgid()) if err != nil { fmt.Println(err) } } Change timestamps As well as a Chtimes</description></item><item><title>How to write a file in go</title><link>https://learngolang.net/tutorials/how-to-write-a-file-in-go/</link><pubDate>Fri, 05 Oct 2018 21:21:19 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-write-a-file-in-go/</guid><description>The quickest way to write a file with some bytes is to use ioutil.WriteFile
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io/ioutil&amp;#34; ) func main() { err := ioutil.WriteFile(&amp;#34;somefile&amp;#34;, []byte(&amp;#34;foo\n&amp;#34;), 0644) if err != nil { fmt.Println(&amp;#34;error while writing file&amp;#34;) } } A more explicit way could be to use os.Create
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { f, err := os.Create(&amp;#34;foo.dat&amp;#34;) if err != nil { fmt.Println(&amp;#34;error while creating file&amp;#34;) } defer f.</description></item><item><title>How to create a file in go</title><link>https://learngolang.net/tutorials/how-to-create-a-file-in-go/</link><pubDate>Fri, 05 Oct 2018 10:11:33 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-create-a-file-in-go/</guid><description>Go lets you easily create and write a new file.
Here is an example using create from os package.
package main import &amp;#34;os&amp;#34; func main() { //create a file f, err := os.Create(&amp;#34;foo&amp;#34;) if err != nil { panic(err) } //make sure it closes. defer f.Close() } os.Create creates a file with default mode 0666 , and default file descriptor as O_RDWR .
Here is another explicit example</description></item><item><title>How to check file permissions in go</title><link>https://learngolang.net/tutorials/how-to-check-file-permissions-in-go/</link><pubDate>Tue, 02 Oct 2018 22:43:02 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-check-file-permissions-in-go/</guid><description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { var perms = []int{os.O_RDONLY, os.O_WRONLY} for perm := range perms { file, err := os.OpenFile(&amp;#34;myFile.txt&amp;#34;, perm, 0666) if err != nil { if os.IsNotExist(err) { panic(&amp;#34;File not found.&amp;#34;) } if os.IsPermission(err) { fmt.Println(fmt.Sprintf(&amp;#34;Error: %v permission denied.&amp;#34;, perm)) } } file.Close() } }</description></item><item><title>How to delete a file in go</title><link>https://learngolang.net/tutorials/how-to-delete-a-file-in-go/</link><pubDate>Tue, 02 Oct 2018 22:43:02 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-delete-a-file-in-go/</guid><description>The os package has os.Remove function, which is used to delete a file as shown below.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { err := os.Remove(&amp;#34;test.txt&amp;#34;) if err != nil { fmt.Println(err) } }</description></item><item><title>How to get fileinfo in go</title><link>https://learngolang.net/tutorials/how-to-get-file-info-in-go/</link><pubDate>Tue, 02 Oct 2018 22:43:02 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-get-file-info-in-go/</guid><description>os.stat is used in golang to get all the meta information about a file.
os.stat will return a fileinfo object or an error if the file is not found.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) func main() { fileInfo, err := os.Stat(&amp;#34;myfile.txt&amp;#34;) if err != nil { log.Fatal(err) } fmt.Println(&amp;#34;File name:&amp;#34;, fileInfo.Name()) fmt.Println(&amp;#34;Size in bytes:&amp;#34;, fileInfo.Size()) fmt.Println(&amp;#34;Permissions:&amp;#34;, fileInfo.Mode()) fmt.Println(&amp;#34;Last modified:&amp;#34;, fileInfo.ModTime()) fmt.Println(&amp;#34;Is Directory: &amp;#34;, fileInfo.IsDir()) fmt.Printf(&amp;#34;System interface type: %T\n&amp;#34;, fileInfo.</description></item><item><title>Linking and symlink a file in go</title><link>https://learngolang.net/tutorials/linking-and-symlink-files-using-go/</link><pubDate>Tue, 02 Oct 2018 21:21:19 +0100</pubDate><guid>https://learngolang.net/tutorials/linking-and-symlink-files-using-go/</guid><description>A Link in Linux is just a pointer to a file or a directory.
A hardlink is a new pointer to the same file, hard links actually have file contents.
A softlink does not point directly to the file, and is only a reference. softlinks are also called symlink
Hard Linking in golang package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { err := os.Link(&amp;#34;original.txt&amp;#34;, &amp;#34;hardlink.txt&amp;#34;) if err != nil { fmt.</description></item><item><title>How to check if a file exists in go</title><link>https://learngolang.net/tutorials/how-to-check-if-a-file-exists-in-go/</link><pubDate>Mon, 01 Oct 2018 18:02:05 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-check-if-a-file-exists-in-go/</guid><description>Here is a quick snippet to check if a file exists in go
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { if _, err := os.Stat(&amp;#34;somefile&amp;#34;); os.IsNotExist(err) { fmt.Println(&amp;#34;path to \&amp;#34;somefile\&amp;#34; does not exist&amp;#34;) } } In an edge case a file might disappear between an exist check and open
So, it might be a good idea to always open a file and check for returned err.
If the file does not exist, it can be detected by os.</description></item><item><title>How to rename and move a file in go</title><link>https://learngolang.net/tutorials/how-to-rename-and-move-a-file-in-go/</link><pubDate>Sun, 02 Sep 2018 22:43:02 +0100</pubDate><guid>https://learngolang.net/tutorials/how-to-rename-and-move-a-file-in-go/</guid><description>To rename a file there is os.Rename method, which takes original name and the new name.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { oldname := &amp;#34;file1.txt&amp;#34; newname := &amp;#34;file2.txt&amp;#34; err := os.Rename(oldname, newname) if err != nil { fmt.Println(err) } } The same method can be used to move the file as well.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { originalPath := &amp;#34;file1.txt&amp;#34; newPath := &amp;#34;/some/other/folder/file2.</description></item></channel></rss>